name: "SonarScanner Analysis"
description: "Run SonarScanner analysis with local Docker containers"
author: "Diego Maroto"
branding:
  icon: "check-square"
  color: "blue"

inputs:
  project-key:
    description: "Project key for the analysis"
    required: true
  sources:
    description: "Source directories to analyze"
    required: false
    default: "."
  exclusions:
    description: "Patterns to exclude from analysis"
    required: false
    default: "**/node_modules/**,**/dist/**"
  wait-for-server:
    description: "Time in seconds to wait for SonarQube server to start"
    required: false
    default: "60"
  retention-days:
    description: "Number of days to retain the uploaded artifact"
    required: false
    default: "7"

runs:
  using: "composite"
  steps:
    - name: Set up Docker
      shell: bash
      run: docker --version

    - name: Start SonarQube Server
      shell: bash
      run: |
        echo "Starting SonarQube server container..."
        docker run -d --name sonar-server \
          -p 9000:9000 \
          sonarqube:lts-community

        # Wait for server to be ready
        echo "Waiting for SonarQube to start..."
        timeout=${{ inputs.wait-for-server }}
        until curl -s http://localhost:9000/api/system/status | grep -q '"status":"UP"'; do
          if [ "$timeout" -le 0 ]; then
            echo "Timeout waiting for SonarQube server"
            exit 1
          fi
          echo "Waiting... ($timeout seconds remaining)"
          sleep 5
          timeout=$((timeout - 5))
        done

        # Get default token (for community edition)
        echo "Generating authentication token..."
        TOKEN=$(docker exec sonar-server wget -qO- --auth-no-challenge \
          --http-user=admin --http-password=admin \
          --header="Content-Type: application/x-www-form-urlencoded" \
          --post-data="name=test-token" \
          http://localhost:9000/api/user_tokens/generate | grep -o '"token":"[^"]*' | cut -d'"' -f4)

        echo "SONAR_TOKEN=${TOKEN}" >> $GITHUB_ENV

    - name: Run SonarScanner
      shell: bash
      run: |
        echo "Running SonarScanner analysis..."
        echo "Debug: Current directory contents:"
        ls -la

        echo "Debug: Workspace contents:"
        ls -la ${{ github.workspace }}

        echo "Debug: Sources path contents:"
        ls -la ${{ inputs.sources }}

        echo "Debug: Environment variables:"
        printenv | grep SONAR

        echo "Debug: Token validation:"
        curl -s -u "${SONAR_TOKEN}:" http://localhost:9000/api/authentication/validate

        echo "Running scanner with verbose output..."
        docker run --rm \
          --network="host" \
          -v "${{ github.workspace }}:/usr/src" \
          -e SONAR_HOST_URL="http://localhost:9000" \
          -e SONAR_TOKEN="${SONAR_TOKEN}" \
          -e SONAR_VERBOSE="true" \
          -e SONAR_SCANNER_OPTS="-Dsonar.projectKey=${{ inputs.project-key }} \
            -Dsonar.token=${SONAR_TOKEN} \
            -Dsonar.sources=${{ inputs.sources }} \
            -Dsonar.exclusions=${{ inputs.exclusions }} \
            -Dsonar.scm.provider=git \
            -Dsonar.sourceEncoding=UTF-8 \
            -Dsonar.verbose=true \
            -Dsonar.log.level=DEBUG \
            -X" \
          sonarsource/sonar-scanner-cli 2>&1 | tee sonar_analysis.log

        echo "Debug: Checking if project was created:"
        curl -s -u "${SONAR_TOKEN}:" "http://localhost:9000/api/projects/search?projects=${{ inputs.project-key }}" | jq .

    - name: Package Results
      shell: bash
      run: |
        TIMESTAMP=$(date +%Y%m%d_%H%M%S)
        RESULTS_DIR="sonar-results_${TIMESTAMP}"
        mkdir -p "${RESULTS_DIR}"

        # Wait for analysis to complete
        echo "Waiting for analysis to complete..."
        sleep 30  # Give SonarQube time to process

        # Check if analysis is complete
        ANALYSIS_ID=$(curl -s -u "${SONAR_TOKEN}:" \
          "http://localhost:9000/api/ce/activity?component=${{ inputs.project-key }}" | \
          jq -r '.tasks[0].id')

        if [ ! -z "$ANALYSIS_ID" ]; then
          echo "Waiting for analysis task $ANALYSIS_ID to complete..."
          while true; do
            STATUS=$(curl -s -u "${SONAR_TOKEN}:" \
              "http://localhost:9000/api/ce/task?id=${ANALYSIS_ID}" | \
              jq -r '.task.status')
            
            if [ "$STATUS" = "SUCCESS" ]; then
              echo "Analysis complete!"
              break
            elif [ "$STATUS" = "FAILED" ]; then
              echo "Analysis failed!"
              exit 1
            fi
            echo "Analysis still processing... Status: $STATUS"
            sleep 10
          done
        fi

        {
          echo "# üîç SonarQube Analysis Results"
          echo "## Project Information"
          echo "- **Project Key**: ${{ inputs.project-key }}"
          echo "- **Date**: $(date)"
          echo "- **Runner**: ${{ runner.os }}"
          
          echo "## üéØ Quality Gate Status"
          QUALITY_GATE=$(curl -s -u "${SONAR_TOKEN}:" \
            "http://localhost:9000/api/qualitygates/project_status?projectKey=${{ inputs.project-key }}")
          
          STATUS=$(echo "$QUALITY_GATE" | jq -r '.projectStatus.status // "N/A"')
          echo "**Status**: ${STATUS}"
          
          echo "## üìä Metrics"
          METRICS=$(curl -s -u "${SONAR_TOKEN}:" \
            "http://localhost:9000/api/measures/component?component=${{ inputs.project-key }}&metricKeys=bugs,vulnerabilities,code_smells,coverage,duplicated_lines_density,reliability_rating,security_rating,sqale_rating")
          
          echo "| Metric | Value | Rating |"
          echo "|--------|--------|--------|"
          
          # Function to safely get metric value
          get_metric_value() {
            local metric=$1
            echo "$METRICS" | jq -r --arg metric "$metric" \
              '.component.measures[] | select(.metric == $metric) | .value // "N/A"'
          }

          # Function to convert rating to letter
          convert_rating() {
            case $1 in
              "1") echo "A" ;;
              "2") echo "B" ;;
              "3") echo "C" ;;
              "4") echo "D" ;;
              "5") echo "E" ;;
              *) echo "N/A" ;;
            esac
          }

          # Print metrics with safe value extraction
          metrics=(
            "bugs|reliability_rating"
            "vulnerabilities|security_rating"
            "code_smells|sqale_rating"
            "coverage|"
            "duplicated_lines_density|"
          )

          for metric_pair in "${metrics[@]}"; do
            IFS="|" read -r metric rating_metric <<< "$metric_pair"
            value=$(get_metric_value "$metric")
            if [ -n "$rating_metric" ]; then
              rating=$(get_metric_value "$rating_metric")
              rating_letter=$(convert_rating "$rating")
            else
              rating_letter="N/A"
            fi
            echo "| ${metric^} | ${value:-0} | $rating_letter |"
          done

          echo "## üîç Issues Breakdown"
          ISSUES=$(curl -s -u "${SONAR_TOKEN}:" \
            "http://localhost:9000/api/issues/search?componentKeys=${{ inputs.project-key }}&resolved=false")
          
          echo "### By Type"
          echo "| Type | Count |"
          echo "|------|-------|"
          echo "$ISSUES" | jq -r '
            [.issues[] | .type] | group_by(.) | map({type: .[0], count: length}) |
            .[] | "| \(.type) | \(.count) |"
          ' || echo "| No issues found | 0 |"
          
          echo "### By Severity"
          echo "| Severity | Count |"
          echo "|----------|--------|"
          echo "$ISSUES" | jq -r '
            [.issues[] | .severity] | group_by(.) | map({severity: .[0], count: length}) |
            .[] | "| \(.severity) | \(.count) |"
          ' || echo "| No issues found | 0 |"
          
        } >> "${RESULTS_DIR}/analysis_report.md"

        # Create ZIP archive
        zip -r "sonar-results_${TIMESTAMP}.zip" "${RESULTS_DIR}"

    - name: Upload Results
      uses: actions/upload-artifact@v4
      with:
        name: sonar-analysis-results
        path: sonar-results_*.zip
        retention-days: ${{ inputs.retention-days }}

    - name: Cleanup
      shell: bash
      if: always()
      run: |
        echo "Stopping SonarQube server..."
        docker stop sonar-server || true
        docker rm sonar-server || true
